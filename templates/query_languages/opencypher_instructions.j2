## OpenCypher Query Language Instructions

### Property Graph Pattern Syntax
OpenCypher uses ASCII-art style patterns to match graph structures with nodes and relationships.

### Basic Pattern Syntax

**Node patterns:**
- `(n)` - Any node assigned to variable `n`
- `(n:{{ schema.vertices[0].label }})` - Node with specific label
- `(n:{{ schema.vertices[0].label }} {property: 'value'})` - Node with property filter

**Relationship patterns:**
- `(a)-[r]->(b)` - Directed relationship from a to b
- `(a)-[r:{{ schema.edges[0].label }}]->(b)` - Relationship with specific type
- `(a)-[r {property: value}]->(b)` - Relationship with properties

### Vertex and Edge Structure
{% for vertex in schema.vertices %}
**{{ vertex.label }} Nodes:**
Available properties:
{% for prop_name, prop_info in vertex.properties.items() %}
  - `{{ prop_name }}`: {{ prop_info.description }}
    {% if prop_info.examples %}Example values: {{ prop_info.examples | join(', ') }}{% endif %}
    {% if prop_info.enum %}Allowed values: {{ prop_info.enum | join(', ') }}{% endif %}
{% endfor %}

{% endfor %}

{% for edge in schema.edges %}
**{{ edge.label }} Relationships:**
  - Pattern: `(:{{ edge.from_vertex }})-[:{{ edge.label }}]->(:{{ edge.to_vertex }})`
  - Description: {{ edge.description }}
  {% if edge.properties %}
  Relationship properties:
  {% for prop_name, prop_info in edge.properties.items() %}
    - `{{ prop_name }}`: {{ prop_info.description }}
  {% endfor %}
  {% endif %}

{% endfor %}

### Common Query Patterns

**Find nodes by property:**
```cypher
MATCH (n:{{ schema.vertices[0].label }} {property_name: 'value'})
RETURN n
```

**Traverse relationships:**
```cypher
MATCH (a:{{ schema.vertices[0].label }})-[r:{{ schema.edges[0].label }}]->(b)
WHERE a.property_name = 'value'
RETURN a, r, b
```

**Count nodes:**
```cypher
MATCH (n:{{ schema.vertices[0].label }})
RETURN count(n) as total_count
```

**Filter by multiple properties:**
```cypher
MATCH (n:{{ schema.vertices[0].label }})
WHERE n.prop1 = 'value1' AND n.prop2 = 'value2'
RETURN n
```

**Get specific properties:**
```cypher
MATCH (n:{{ schema.vertices[0].label }})
RETURN n.property1, n.property2
```

**Pattern matching with optional relationships:**
```cypher
MATCH (a:{{ schema.vertices[0].label }})
OPTIONAL MATCH (a)-[r:{{ schema.edges[0].label }}]->(b)
RETURN a, r, b
```

### Query Structure Examples

**Basic MATCH-RETURN:**
```cypher
MATCH (pattern)
WHERE conditions
RETURN projection
ORDER BY property
LIMIT number
```

**CREATE (Insert) Pattern:**
```cypher
CREATE (n:{{ schema.vertices[0].label }} {property: 'value'})
RETURN n
```

**CREATE Relationship:**
```cypher
MATCH (a:{{ schema.vertices[0].label }}), (b:{{ schema.vertices[0].label }})
WHERE a.guid = 'guid1' AND b.guid = 'guid2'
CREATE (a)-[r:{{ schema.edges[0].label }}]->(b)
RETURN r
```

### Property Data Types
{% for vertex in schema.vertices %}
{{ vertex.label }} node properties:
{% for prop_name, prop_info in vertex.properties.items() %}
{% if prop_info.enum %}
- `{{ prop_name }}`: Use values {{ prop_info.enum | join(' or ') }}
{% elif prop_info.note %}
- `{{ prop_name }}`: {{ prop_info.note }}
{% endif %}
{% endfor %}
{% endfor %}

### Neptune OpenCypher Specifics
- String values use single or double quotes
- Property names are case-sensitive
- Node labels are case-sensitive
- Use `LIMIT` to prevent large result sets
- Relationship direction matters: `->` vs `<-`
- Use `WHERE` clause for complex filtering

### Result Format
OpenCypher results are already in tabular format, matching your RETURN clause:
`{"results": [{"field1": value1, "field2": value2}, ...]}`

Field names in results match your RETURN clause aliases. No additional transformation needed.

### Parameterized Queries
OpenCypher supports parameterized queries for safety and performance:
- Use `$param` syntax in queries for parameter placeholders
- Parameters help prevent injection and improve query plan caching
- Example: `MATCH (n:Person {name: $userName}) RETURN n`
- Parameters passed separately to the query execution

### Best Practices for Neptune OpenCypher
- **Pattern Matching:**
  - Start with `MATCH` patterns that define graph structure
  - Use specific node labels: `MATCH (n:Person)` not `MATCH (n)`
  - Apply `WHERE` filters early to reduce result sets
  - Use meaningful variable names in patterns

- **Performance Optimization:**
  - Add `LIMIT` clauses for potentially large results
  - Combine `ORDER BY` with `LIMIT` for consistent pagination
  - Prefer pattern matching over procedural WHERE logic
  - Use indexes by filtering on indexed properties
  - Apply most restrictive filters first

- **Query Structure:**
  - Use specific node labels and relationship types
  - Leverage OPTIONAL MATCH for optional patterns
  - Use WITH clauses to pipe results between query parts
  - Prefer RETURN aliases for clear field names

- **Data Access:**
  - Use property access syntax: `n.propertyName`
  - Leverage pattern comprehensions for complex logic
  - Use CASE expressions for conditional values
  - Apply functions like `count()`, `collect()`, `avg()` appropriately

### Common Performance Patterns
- **Restrictive start:** Begin with most selective pattern
- **Early filtering:** Apply WHERE conditions as soon as possible
- **Index usage:** Filter on properties that have indexes
- **Limit early:** Use LIMIT to cap intermediate results
- **Property existence:** Check property existence with `WHERE EXISTS(n.property)`
