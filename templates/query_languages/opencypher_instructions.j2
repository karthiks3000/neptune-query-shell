## OpenCypher Query Language Instructions

### Property Graph Pattern Syntax
OpenCypher uses ASCII-art style patterns to match graph structures with nodes and relationships.

### Basic Pattern Syntax

**Node patterns:**
- `(n)` - Any node assigned to variable `n`
- `(n:{{ schema.vertices[0].label }})` - Node with specific label
- `(n:{{ schema.vertices[0].label }} {property: 'value'})` - Node with property filter

**Relationship patterns:**
- `(a)-[r]->(b)` - Directed relationship from a to b
- `(a)-[r:{{ schema.edges[0].label }}]->(b)` - Relationship with specific type
- `(a)-[r {property: value}]->(b)` - Relationship with properties

### Vertex and Edge Structure
{% for vertex in schema.vertices %}
**{{ vertex.label }} Nodes:**
Available properties:
{% for prop_name, prop_info in vertex.properties.items() %}
  - `{{ prop_name }}`: {{ prop_info.description }}
    {% if prop_info.examples %}Example values: {{ prop_info.examples | join(', ') }}{% endif %}
    {% if prop_info.enum %}Allowed values: {{ prop_info.enum | join(', ') }}{% endif %}
{% endfor %}

{% endfor %}

{% for edge in schema.edges %}
**{{ edge.label }} Relationships:**
  - Pattern: `(:{{ edge.from_vertex }})-[:{{ edge.label }}]->(:{{ edge.to_vertex }})`
  - Description: {{ edge.description }}
  {% if edge.properties %}
  Relationship properties:
  {% for prop_name, prop_info in edge.properties.items() %}
    - `{{ prop_name }}`: {{ prop_info.description }}
  {% endfor %}
  {% endif %}

{% endfor %}

### Common Query Patterns

**Find nodes by property:**
```cypher
MATCH (n:{{ schema.vertices[0].label }} {property_name: 'value'})
RETURN n
```

**Traverse relationships:**
```cypher
MATCH (a:{{ schema.vertices[0].label }})-[r:{{ schema.edges[0].label }}]->(b)
WHERE a.property_name = 'value'
RETURN a, r, b
```

**Count nodes:**
```cypher
MATCH (n:{{ schema.vertices[0].label }})
RETURN count(n) as total_count
```

**Filter by multiple properties:**
```cypher
MATCH (n:{{ schema.vertices[0].label }})
WHERE n.prop1 = 'value1' AND n.prop2 = 'value2'
RETURN n
```

**Get specific properties:**
```cypher
MATCH (n:{{ schema.vertices[0].label }})
RETURN n.property1, n.property2
```

**Pattern matching with optional relationships:**
```cypher
MATCH (a:{{ schema.vertices[0].label }})
OPTIONAL MATCH (a)-[r:{{ schema.edges[0].label }}]->(b)
RETURN a, r, b
```

### Query Structure Examples

**Basic MATCH-RETURN:**
```cypher
MATCH (pattern)
WHERE conditions
RETURN projection
ORDER BY property
LIMIT number
```

**CREATE (Insert) Pattern:**
```cypher
CREATE (n:{{ schema.vertices[0].label }} {property: 'value'})
RETURN n
```

**CREATE Relationship:**
```cypher
MATCH (a:{{ schema.vertices[0].label }}), (b:{{ schema.vertices[0].label }})
WHERE a.guid = 'guid1' AND b.guid = 'guid2'
CREATE (a)-[r:{{ schema.edges[0].label }}]->(b)
RETURN r
```

### Property Data Types
{% for vertex in schema.vertices %}
{{ vertex.label }} node properties:
{% for prop_name, prop_info in vertex.properties.items() %}
{% if prop_info.enum %}
- `{{ prop_name }}`: Use values {{ prop_info.enum | join(' or ') }}
{% elif prop_info.note %}
- `{{ prop_name }}`: {{ prop_info.note }}
{% endif %}
{% endfor %}
{% endfor %}

### Neptune OpenCypher Specifics
- String values use single or double quotes
- Property names are case-sensitive
- Node labels are case-sensitive
- Use `LIMIT` to prevent large result sets
- Relationship direction matters: `->` vs `<-`
- Use `WHERE` clause for complex filtering

### Best Practices
- Start with `MATCH` patterns that define graph structure
- Use specific node labels rather than matching all nodes
- Apply `WHERE` filters to reduce result sets
- Use meaningful variable names in patterns
- Add `LIMIT` clauses for potentially large results
- Combine `ORDER BY` with `LIMIT` for consistent pagination
